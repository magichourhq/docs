---
title: Adding API to Your App
description: Complete guide to integrating Magic Hour APIs into your production application.
---

This guide walks you through integrating Magic Hour APIs into your production application. You'll learn the complete workflow from making API calls to handling responses, errors, and file management.

## What you'll accomplish

By the end of this guide, you'll have:
- ‚úÖ Secure API integration setup
- ‚úÖ Complete create ‚Üí poll ‚Üí download workflow  
- ‚úÖ Robust error handling
- ‚úÖ Production-ready patterns

## Before you start

<Tip>Complete the [Quick Start Guide](/get-started/quick-start) first to get familiar with basic API calls.</Tip>

**Prerequisites:**
- API key from [Developer Hub](https://magichour.ai/developer?tab=api-keys)
- Your preferred [SDK](/sdks/overview) installed or direct HTTP client ready

<Warning>
  **Security:** Never expose your API key in client-side code. Always keep it secure on your server to prevent unauthorized usage.
</Warning>

## Integration overview

Magic Hour APIs follow a simple 3-step pattern:

**Step 1: Create Job** ‚Üí **Step 2: Check Status** ‚Üí **Step 3: Download Result**
                                   ‚Üë_________________‚Üì
                                   (Poll until complete)

1. **Create** - Submit your job (image/video generation)
2. **Poll** - Check status until complete
3. **Download** - Retrieve your generated content

## Complete integration example

Here's a full end-to-end example that demonstrates the complete workflow:

<CodeGroup>

```python Python SDK
from magic_hour import Client
import time

client = Client(token="YOUR_API_KEY")

# 1. Create job
print("Creating face swap job...")
create_res = client.v1.face_swap.create(
    name="My face swap",
    assets={
        "image_file_path": "https://example.com/face.jpg",
        "video_file_path": "https://example.com/video.mp4",
        "video_source": "file"
    },
    start_seconds=0.0,
    end_seconds=10.0,
    height=512,
    width=512
)

project_id = create_res.id
print(f"Job created: {project_id}")

# 2. Poll for completion
print("Waiting for completion...")
while True:
    status_res = client.v1.video_projects.get(id=project_id)
    print(f"Status: {status_res.status}")
    
    if status_res.status == "complete":
        print("‚úÖ Render complete!")
        
        # 3. Download result
        download_url = status_res.downloads[0].url
        import requests
        with open("result.mp4", "wb") as file:
            response = requests.get(download_url)
            file.write(response.content)
        print("üìÅ File downloaded: result.mp4")
        break
        
    elif status_res.status == "error":
        print(f"‚ùå Error: {status_res.error}")
        break
        
    time.sleep(5)  # Wait 5 seconds before next check
```

```typescript Node SDK
import Client from "magic-hour";
import { writeFileSync } from "fs";

const client = new Client({ token: "YOUR_API_KEY" });

async function createAndDownload() {
  // 1. Create job
  console.log("Creating face swap job...");
  const createRes = await client.v1.faceSwap.create({
    name: "My face swap",
    assets: {
      imageFilePath: "https://example.com/face.jpg",
      videoFilePath: "https://example.com/video.mp4",
      videoSource: "file"
    },
    startSeconds: 0.0,
    endSeconds: 10.0,
    height: 512,
    width: 512
  });

  const projectId = createRes.id;
  console.log(`Job created: ${projectId}`);

  // 2. Poll for completion
  console.log("Waiting for completion...");
  while (true) {
    const statusRes = await client.v1.videoProjects.get({ id: projectId });
    console.log(`Status: ${statusRes.status}`);

    if (statusRes.status === "complete") {
      console.log("‚úÖ Render complete!");
      
      // 3. Download result
      const downloadUrl = statusRes.downloads[0].url;
      const response = await fetch(downloadUrl);
      const buffer = await response.arrayBuffer();
      writeFileSync("result.mp4", Buffer.from(buffer));
      console.log("üìÅ File downloaded: result.mp4");
      break;
      
    } else if (statusRes.status === "error") {
      console.log(`‚ùå Error: ${statusRes.error}`);
      break;
    }

    await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
  }
}

createAndDownload();
```

</CodeGroup>

## Working with input files

Magic Hour accepts input files in two ways:

### Option 1: URL references (Recommended)

The simplest approach is to pass publicly accessible URLs:

```json
{
  "assets": {
    "image_file_path": "https://cdn.yourwebsite.com/face.jpg",
    "video_file_path": "https://cdn.yourwebsite.com/video.mp4"
  }
}
```

**Supported formats:**
- **Images**: PNG, JPG, JPEG, WEBP, AVIF
- **Videos**: MP4, MOV, WEBM  
- **Audio**: MP3, WAV, AAC, FLAC

### Option 2: Upload to Magic Hour

For secure or temporary files, upload directly to Magic Hour storage:

<Card title="Input Files Guide" icon="file" href="/integration/input-files">
  Complete guide to file uploads, formats, and storage options
</Card>

## Understanding job status

Every job goes through these states:

| Status      | Description                                | Action Required |
| :---------- | :----------------------------------------- | :------------- |
| `queued`    | Job is waiting for available server       | ‚è≥ Keep polling |
| `rendering` | Job is being processed                     | ‚è≥ Keep polling |
| `complete`  | Job finished successfully                  | ‚úÖ Download result |
| `error`     | Job failed during processing              | ‚ùå Handle error |
| `canceled`  | Job was manually canceled                  | üõë Job stopped |

### Recommended polling intervals

- **Images**: Check every 2-3 seconds (usually complete within 30-60 seconds)
- **Videos**: Check every 5-10 seconds (can take 2-5 minutes depending on length)

## Error handling best practices

When a job fails (`status: "error"`), the response includes detailed error information:

```json
{
  "status": "error",
  "error": {
    "code": "no_source_face", 
    "message": "Please use an image with a detectable face"
  }
}
```

### Common error codes

| Error Code | Description | Solution |
|:-----------|:------------|:---------|
| `no_source_face` | No detectable face in image | Use image with clear, visible face |
| `invalid_file_format` | Unsupported file type | Check [supported formats](#working-with-input-files) |
| `file_too_large` | File exceeds size limits | Compress file or use smaller input |
| `insufficient_credits` | Not enough credits | Add credits to your account |
| `invalid_parameters` | Request parameters are invalid | Check API documentation |

### Error handling example

<CodeGroup>

```python Python SDK
try:
    create_res = client.v1.face_swap.create(...)
    
    # Poll with error handling
    while True:
        status_res = client.v1.video_projects.get(id=create_res.id)
        
        if status_res.status == "complete":
            # Success - download result
            break
        elif status_res.status == "error":
            error_code = status_res.error.get("code", "unknown")
            error_msg = status_res.error.get("message", "Unknown error")
            
            # Handle specific errors
            if error_code == "no_source_face":
                print("‚ùå No face detected. Please use a different image.")
            elif error_code == "insufficient_credits":
                print("üí≥ Not enough credits. Please add credits to continue.")
            else:
                print(f"‚ùå Error ({error_code}): {error_msg}")
            break
            
        time.sleep(5)
        
except Exception as e:
    print(f"‚ùå Request failed: {e}")
```

```typescript Node SDK
try {
  const createRes = await client.v1.faceSwap.create({...});
  
  // Poll with error handling
  while (true) {
    const statusRes = await client.v1.videoProjects.get({ id: createRes.id });
    
    if (statusRes.status === "complete") {
      // Success - download result
      break;
    } else if (statusRes.status === "error") {
      const errorCode = statusRes.error?.code || "unknown";
      const errorMsg = statusRes.error?.message || "Unknown error";
      
      // Handle specific errors
      switch (errorCode) {
        case "no_source_face":
          console.log("‚ùå No face detected. Please use a different image.");
          break;
        case "insufficient_credits":
          console.log("üí≥ Not enough credits. Please add credits to continue.");
          break;
        default:
          console.log(`‚ùå Error (${errorCode}): ${errorMsg}`);
      }
      break;
    }
    
    await new Promise(resolve => setTimeout(resolve, 5000));
  }
} catch (error) {
  console.log(`‚ùå Request failed: ${error}`);
}
```

</CodeGroup>

<Note>For `unknown_error` codes, contact [support@magichour.ai](mailto:support@magichour.ai) with your project ID for investigation.</Note>

## Status monitoring strategies

Choose the right approach based on your application's needs:

### Option 1: Webhooks (Recommended for production)

Get real-time notifications when jobs complete. Best for:
- ‚úÖ Production applications
- ‚úÖ Video processing (longer render times)
- ‚úÖ Multiple concurrent jobs
- ‚úÖ Better server resource usage

<Card title="Webhook Setup Guide" icon="webhook" href="/integration/webhook/overview">
  Complete webhook implementation guide with examples
</Card>

### Option 2: Polling (Good for simple use cases)

Periodically check job status. Best for:
- ‚úÖ Simple integrations
- ‚úÖ Single job processing
- ‚úÖ Image generation (quick results)
- ‚ö†Ô∏è Be mindful of rate limits

**Smart polling example:**

<CodeGroup>

```python Python SDK
import time

def wait_for_completion(client, project_id, project_type="video"):
    """Smart polling with exponential backoff"""
    
    get_method = (client.v1.video_projects.get if project_type == "video" 
                 else client.v1.image_projects.get)
    
    max_wait = 300  # 5 minutes max
    start_time = time.time()
    interval = 2  # Start with 2 seconds
    
    while time.time() - start_time < max_wait:
        try:
            res = get_method(id=project_id)
            print(f"Status: {res.status}")
            
            if res.status == "complete":
                return res  # Success!
            elif res.status == "error":
                raise Exception(f"Job failed: {res.error}")
                
            # Smart interval adjustment
            if res.status == "queued":
                interval = min(interval * 1.5, 10)  # Increase wait time
            else:  # rendering
                interval = 3  # Steady polling during render
                
            time.sleep(interval)
            
        except Exception as e:
            print(f"Error checking status: {e}")
            time.sleep(5)
    
    raise TimeoutError("Job did not complete within timeout")
```

```typescript Node SDK
async function waitForCompletion(
  client: Client, 
  projectId: string, 
  projectType: "video" | "image" = "video"
) {
  const getMethod = projectType === "video" 
    ? client.v1.videoProjects.get 
    : client.v1.imageProjects.get;
    
  const maxWait = 300000; // 5 minutes in ms
  const startTime = Date.now();
  let interval = 2000; // Start with 2 seconds
  
  while (Date.now() - startTime < maxWait) {
    try {
      const res = await getMethod({ id: projectId });
      console.log(`Status: ${res.status}`);
      
      if (res.status === "complete") {
        return res; // Success!
      } else if (res.status === "error") {
        throw new Error(`Job failed: ${res.error}`);
      }
      
      // Smart interval adjustment
      if (res.status === "queued") {
        interval = Math.min(interval * 1.5, 10000); // Increase wait time
      } else { // rendering
        interval = 3000; // Steady polling during render
      }
      
      await new Promise(resolve => setTimeout(resolve, interval));
      
    } catch (error) {
      console.log(`Error checking status: ${error}`);
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }
  
  throw new Error("Job did not complete within timeout");
}
```

</CodeGroup>

### Rate limiting considerations

- **Don't poll faster than once per second**
- **Use exponential backoff** when jobs are queued
- **Implement timeout limits** (max 5-10 minutes)
- **Handle network errors gracefully**

## Downloading results

When a job completes, the `downloads` array is populated with secure, time-limited URLs:

```json
{
  "status": "complete",
  "downloads": [
    {
      "url": "https://video.magichour.ai/id/output.mp4?auth-token=1234",
      "expires_at": "2024-10-19T05:16:19.027Z"
    }
  ]
}
```

<Warning>Download URLs expire after 24 hours. Download files immediately after job completion.</Warning>

### Production download handling

<CodeGroup>

```python Python SDK
import requests
import os
from pathlib import Path

def download_result(download_info, output_dir="./downloads"):
    """Robust download with error handling"""
    
    # Create output directory
    Path(output_dir).mkdir(exist_ok=True)
    
    # Generate filename from URL or use timestamp
    url = download_info["url"]
    filename = f"result_{int(time.time())}.mp4"  # or extract from URL
    filepath = Path(output_dir) / filename
    
    try:
        print(f"Downloading to {filepath}...")
        response = requests.get(url, stream=True, timeout=60)
        response.raise_for_status()
        
        # Stream download for large files
        with open(filepath, "wb") as file:
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)
                
        print(f"‚úÖ Downloaded: {filepath} ({filepath.stat().st_size} bytes)")
        return str(filepath)
        
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Download failed: {e}")
        return None
```

```typescript Node SDK
import fs from 'fs';
import path from 'path';

async function downloadResult(downloadInfo: any, outputDir = './downloads') {
  // Create output directory
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Generate filename
  const filename = `result_${Date.now()}.mp4`;
  const filepath = path.join(outputDir, filename);
  
  try {
    console.log(`Downloading to ${filepath}...`);
    
    const response = await fetch(downloadInfo.url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    // Stream download for large files
    const arrayBuffer = await response.arrayBuffer();
    fs.writeFileSync(filepath, Buffer.from(arrayBuffer));
    
    const stats = fs.statSync(filepath);
    console.log(`‚úÖ Downloaded: ${filepath} (${stats.size} bytes)`);
    return filepath;
    
  } catch (error) {
    console.log(`‚ùå Download failed: ${error}`);
    return null;
  }
}
```

</CodeGroup>

### Multiple outputs handling

Some tools generate multiple files (e.g., multiple images):

```python
# Handle multiple downloads
for i, download in enumerate(status_res.downloads):
    filename = f"output_{i+1}.{'mp4' if 'video' in download.url else 'jpg'}"
    download_result(download, filename)
```

## Production best practices

### 1. Resource management

**Clean up completed jobs:**
```python
# Delete job after downloading to save storage
client.v1.video_projects.delete(id=project_id)
```

**Monitor credit usage:**
```python
# Check credit balance before expensive operations
account_info = client.v1.account.get()
if account_info.credits < estimated_cost:
    # Handle insufficient credits
    pass
```

### 2. Performance optimization

**Batch operations:**
- Process multiple jobs concurrently (mind rate limits)
- Use webhooks for high-volume scenarios
- Implement job queues for better resource management

**Optimize file handling:**
- Use CDN URLs for input files when possible
- Compress large input files before processing
- Stream downloads for large outputs

### 3. Error resilience

**Implement retry logic:**
```python
import time
from functools import wraps

def retry_on_failure(max_retries=3, delay=1):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1:
                        raise e
                    time.sleep(delay * (2 ** attempt))  # Exponential backoff
            return wrapper
    return decorator

@retry_on_failure(max_retries=3)
def create_job_with_retry():
    return client.v1.face_swap.create(...)
```

**Monitor and log:**
- Log all API calls with timestamps and project IDs
- Track success/failure rates
- Set up alerts for high error rates

### 4. Security considerations

- **Never expose API keys** in client-side code
- **Validate file inputs** before sending to API
- **Use HTTPS** for all file URLs
- **Implement rate limiting** in your application

## File management

### Cleaning up storage

Generated files are stored indefinitely. Clean up completed jobs to manage storage:

<CodeGroup>
```python Python SDK
# Clean up after successful download
client.v1.video_projects.delete(id=project_id)
```

```typescript Node SDK
// Clean up after successful download  
await client.v1.videoProjects.delete({ id: projectId });
```
</CodeGroup>

<Warning>Deletion is permanent and cannot be undone. Only delete after confirming successful download.</Warning>
## Development and testing

### Free testing with mock server

Avoid credit charges during development by using the mock API server:

<Info>
  The mock server returns realistic sample data without processing jobs or charging credits.
</Info>

<CodeGroup>

```python Python SDK
from magic_hour import Client
from magic_hour.environment import Environment

# Use mock server for development
client = Client(
    token="API_TOKEN", 
    environment=Environment.MOCK_SERVER
)

# All API calls will return mock data
result = client.v1.face_swap.create(...)  # No credits charged
```

```typescript Node SDK
import Client, { Environment } from "magic-hour";

// Use mock server for development
const client = new Client({
  token: "API_TOKEN",
  environment: Environment.MockServer,
});

// All API calls will return mock data
const result = await client.v1.faceSwap.create({...}); // No credits charged
```

</CodeGroup>

### Emergency job cancellation

Cancel video jobs (with full refund) via the web dashboard:

<Steps>
  <Step title="Open video details">
    Visit: `https://magichour.ai/dashboard/videos/{project_id}`
  </Step>
  <Step title="Click Cancel Render">
    ![Cancel Render Button](./images/cancel-1.png)
  </Step>
  <Step title="Confirm cancellation">
    ![Confirm Cancel Button](./images/cancel-2.jpg)
  </Step>
  <Step title="Cancellation complete">
    ![Cancel Success](./images/cancel-3.png)
  </Step>
</Steps>

<Note>
- Image jobs cannot be cancelled (they complete too quickly)
- API-based cancellation is not currently available
- Full credit refund is provided for cancelled video jobs
</Note>

## Next steps

<CardGroup cols={2}>
  <Card title="Webhook Integration" icon="webhook" href="/integration/webhook/overview">
    Set up real-time notifications for production apps
  </Card>
  <Card title="API Reference" icon="code" href="/api-reference">
    Explore all available endpoints and parameters
  </Card>
  <Card title="SDK Documentation" icon="book" href="/sdks/overview">
    Language-specific guides and advanced features
  </Card>
  <Card title="File Management" icon="file" href="/integration/input-files">
    Advanced file upload and management techniques
  </Card>
</CardGroup>

---

**Need help?** Join our [Discord community](https://discord.com/invite/JX5rgsZaJp) or email [support@magichour.ai](mailto:support@magichour.ai)
